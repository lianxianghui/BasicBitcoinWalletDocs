== 对冷热钱包的支持

=== 全功能模式与只读模式

BasicBitcoinWallet支持全功能模式和只读模式。在初始化钱包的时候选择“创建新钱包”或“恢复已有钱包”生成的钱包是全功能的，如果选择“导入只读钱包”则生成只读模式钱包。

只读模式存有扩展公钥，可以接收比特币、查看余额、查看所有交易数据、查看本地地址，同时也可以构造比特币的交易，但不能对交易签名，也就无法独自发送比特币。

全功能模式存有根种子，可以生成所有私钥与公钥，所以除了具有只读模式的功能以外还可以对交易进行签名。只读模式所导入的扩展公钥（xpub)是从根种子生成出来的。

=== 对冷钱包与热钱包的支持（离线签名）

冷钱包与热钱包是从钱包是否接入网络来区分的。

对于比特币来说，私钥丢失就意味着私钥所对应的比特币丢失。私钥的主要威胁来自互联网，如果移动设备有漏洞被黑客或恶意程序侵入，黑客或恶意程序就可能会窃取存在设备上的私钥。

为了应对这种风险，BasicBitcoinWallet支持通过生成一对冷热钱包的方式来增强私钥的安全性。

具体的说，这需要两个移动设备，两个设备都安装上BasicBitcoinWallet。

首先第一个设备的钱包初始化成全功能钱包，这个钱包始终不联网，作为冷钱包。然后显示“其它”--“账户信息”--“账户扩展公钥”页面中的扩展公钥二维码。

第二个设备的钱包初始化时选择“导入只读钱包”，扫描第一个钱包的扩展公钥二维码，初始化成与该钱包对应的只读钱包，这个钱包联网，作为热钱包。

由于只读钱包不包含私钥，所以可以任意联网使用，不用担心丢失比特币。最坏的情况是暴露了扩展公钥，这种情况会导致暴漏交易信息，但不会导致比特币丢失。

（注：这里也有一个安全隐患。如果暴露了扩展公钥的同时也暴露了任意一个地址对应的私钥，会导致所有私钥都暴露。但如果按着目前的冷热钱包使用场景，冷钱包不联网就不会暴露私钥，所以不会出现这种问题。关于这个问题的更多信息可以参考： https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch05.asciidoc#hardened-child-key-derivation ）

这里热钱包是只读的，一开始说到只读钱包无法发送比特币，冷钱包是全功能的但又不能联网。那么用户如何发送比特币呢？

在BasicBitcoinWallet中是这样处理的，当用户需要发送比特币时按着如下步骤操作：

1. 热钱包：首先构建交易

2. 热钱包：显示未签名交易数据的二维码

3. 冷钱包：用扫描功能扫描该二维码，成功后会显示未签名交易数据文本。

4. 冷钱包：用户人工核对交易数据文本（主要需要核对交易的接收地址、发送数量、发送地址。具体请参考 <<check_unsigned_transaction_data_text>>）

5. 冷钱包：如果核对无误，点击签名按钮进行签名

6. 冷钱包：显示已签名交易数据的二维码

7. 热钱包：扫描该二维码，然后点击发送按钮发送比特币。

这样就完成了比特币的发送。

通过这样的操作，如果用户能保证：

1. 冷钱包始终被保管良好，且没有进行过联网。（这样就能保证钱包软件没被篡改，私钥也不可能被盗）

2. 在使用冷钱包对交易进行签名前仔细核对所显示的数据文本。

这就能保证即使发生热钱包被人篡改或被恶意软件劫持，生成了指向其他地址的交易数据，因为有用户在冷钱包上核对交易数据这一步，仍然可以保证资金的安全。

从以上可以看到，这是一种通过牺牲一定的便捷性来增加安全性的一种方案。当钱包存有的资金数额比较大时，推荐用这种方式。如果数额比较小，则推荐直接使用联网的全功能钱包。

最终这需要用户自己在便捷性和安全性之间来权衡。


[[check_unsigned_transaction_data_text]]
=== 备注：如何核对未签名交易数据文本

未签名交易文本页面显示的是json格式的文本。主要需要关注的是transactionData和dataForCheckingAddresses。

transactionData字段下是未签名交易数据（交易数据下各个字段的意义请参考相关资料，比如： https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc ）。

dataForCheckingAddresses是用来核对的输出地址数组，这些地址对应了transactionData.out数组下面交易输出中的公钥哈希或脚本哈希（比如“OP_DUP
OP_HASH160 4a74c9313284709ea893c40ce666d5159eebdab5
OP_EQUALVERIFY
OP_CHECKSIG”中的4a74c9313284709ea893c40ce666d5159eebdab5）。

签名之前首先需要核对的是dataForCheckingAddresses字段下的outputAddresses和上面transactionData.out数组下的value确实是你要发送的接收地址和金额。其次核对inputAddresses确实是你所选UTXO的地址，就可以了。

（其实如果钱包下存在有多个UTXO为同一地址的情况，为了万无一失还需要查看pre_out下的hash和n来确定该UTXO是否是你所选的UTXO，不过这需要使用第三方区块链浏览器比如blockchain.info来查看)


